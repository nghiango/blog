{"pageProps":{"frontmatter":{"title":"React testing collection","date":"Feb 16, 2024","excerpt":"This article will collect my experience about React testing","tag":"reactjs","author":"Nghia Ngo","cover_image":"/images/posts/how-you-understand-nodejs/nodejs-cover.jpeg"},"slug":"react-testing","content":"\n# Introduction\n\nTesting is an important part of the development process. It helps us to ensure the quality of the project.\nIn this article, I will collect my experience about testing in React.\n\nIn this article, I will use [Jest](https://jestjs.io/),\n[React Testing Library](https://testing-library.com/docs/react-testing-library/intro/) and\n[msw](https://mswjs.io/) for testing.\n\n# Testing\n\n## Setup testing utilities\n\nAdd a setup for `jest-dom` from `testing-library` to adds custom mathchers for asserting on the DOM nodes, that allows\nyou to do things like `expect(element).toHaveTextContent(/react/i)`.\nRead more on [jest-dom](https://github.com/testing-library/jest-dom).\n\n```tsx\nimport '@testing-library/jest-dom';\nimport { render, screen } from '@testing-library/react';\nimport { ReactElement } from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\n\nconst renderWithProviders = (ui: ReactElement, { route = '/' } = {}) => {\n    Object.defineProperty(window, 'matchMedia', {\n        writable: true,\n        value: jest.fn().mockImplementation((query) => ({\n            matches: false,\n            media: query,\n            onchange: null,\n            addListener: jest.fn(), // Deprecated\n            removeListener: jest.fn(), // Deprecated\n            addEventListener: jest.fn(),\n            removeEventListener: jest.fn(),\n            dispatchEvent: jest.fn(),\n        })),\n    });\n    window.history.pushState({}, 'Test page', route);\n    return render(ui, { wrapper: Router });\n};\n\nexport { renderWithProviders as render, screen };\n```\n\nNow, whenever we want to use `render` and `screen` from `@testing-library/react`, we can use our custom `render`\nand `screen` instead.\n\n## Simple test\n\nWe start with a simple test by rendering a component and check if it's rendered correctly.\n\n```tsx\nimport { render } from 'setupTests';\nimport HomeComponent from 'pages/HomeComponent';\n\ndescribe('Simple test', () => {\n    test('render correctly', () => {\n        const { getByTestId, getAllByTestId } = render(<HomeComponent/>);\n        expect(getByTestId('homeHeader')).toBeTruthy();\n        expect(getAllByTestId('input')).toHaveLength(4);\n    })\n})\n```\n\nAs you can see that, we use `getByTestId` and `getAllByTestId` to get the element by `data-testid` attribute.\nTherefore, in our component, we need to add `data-testid` attribute to the element that we want to test.\n\nFor example:\n\n```tsx\nconst HomeComponent = () => {\n    return (\n        <div>\n            <h1 data-testid=\"homeHeader\">Home</h1>\n            <input data-testid=\"input\"/>\n            <input data-testid=\"input\"/>\n            <input data-testid=\"input\"/>\n            <input data-testid=\"input\"/>\n        </div>\n    )\n}\n```\n\n## Test with Provider\n\nIt is clear that some cases require a context to execute logic inside the component, for example, we have `AdminHeader`\ncomponent and `NormalHeader` component, now we have to check the user from the context to render the correct component.\n\n<div class=\"code-block__title\">HomeComponent.tsx</div>\n\n```tsx\nimport { HomeContext } from 'contexts/homeContext';\n\nconst HomeComponent = () => {\n    const { state } = useContext(HomeContext);\n    return (\n        <>\n            {state.isAdmin ? <AdminHeader data-testid=\"adminHeader\"/> : <NormalHeader data-testid=\"normalHeader\"/>}\n            <Content></Content>\n        </>\n    )\n}\n```\n\nNow to test with the `HomeContext`, we will mock the value of it.\n\n<div class=\"code-block__title\">HomeComponent.test.tsx</div>\n\n```tsx\nimport { render } from 'setupTests';\nimport HomeComponent from 'pages/HomeComponent';\n\ndescribe('Test with context Provider', () => {\n    test('render admin header when isAdmin is true', () => {\n        const mockHomeValueContext = {\n            state: {\n                isAdmin: true\n            },\n            dispatch: jest.fn(),\n        };\n        const { getByTestId } = render(\n            <HomeContext.Provider value={mockHomeValueContext}>\n                <HomeComponent/>\n            </HomeContext.Provider>\n        );\n        expect(getByTestId('adminHeader')).toBeTruthy();\n    })\n})\n```\n\n## Test with Event\n\nIn some cases, we want to test behavior of components after an event is triggered. For example, we click on a button\ninside a component, then it will trigger an action of the component. Now, we will check if the action is triggered\ncorrectly.\n\nWe can use `fireEvent` from `@testing-library/react` to simulate the event.\n\n```tsx\nimport { fireEvent } from '@testing-library/react';\nimport { render } from 'setupTests';\n\ndescribe('Test component after action click', () => {\n    test('menu component', () => {\n        const mockClick = jest.fn();\n        const mockItems = [\n            { id: 'id-1', label: 'label-1', icon: 'icon-1' },\n            { id: 'id-2', label: 'label-2', icon: 'icon-2' }\n        ];\n        const mockMenuProps = {\n            items: mockItems,\n            selectedItemKey: mockItems[0].id,\n            onItemClick: mockClick,\n        };\n        const { getByText } = render(<Menu {...mockMenuProps} />);\n        const menuItem = getByText('label-2');\n        fireEvent.click(menuItem);\n        expect(mockClick).toHaveBeenCalledTimes(1);\n    })\n})\n```\n\n## Test with API\n\nHow about if we want to test the component that fetches data from an API? Actually, we have two ways to do it.\n\n- The first way, using mocking HTTP server(msw, nock) to mock a API server, that means we mock at the network level.\n- The second way, using jest mock data to mock calling api, that means we mock at code function level.\n\nIn conclusion, I prefer mocking with HTTP server more than using jest mock, because we don't need to handle any logics\ncompared to some complexity configurations before and after calling API.\n\n### Mocking HTTP server with msw\n\n```tsx\nimport userEvent from '@testing-library/user-event';\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { render, screen } from 'setupTests';\n\nconst server = setupServer(\n    rest.get('/greeting', (req, res, ctx) => {\n        return res(ctx.json({ nickName: 'Hello world' }));\n    }),\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('Render component correctly after data loaded', () => {\n    test('Home component render correctly', async () => {\n        render(<HomeComponent/>)\n\n        await userEvent.click(screen.getByText('Load Nickname'));\n        expect(screen.getByRole('span')).toHaveTextContent('Hello world')\n    })\n})\n```\n\nBy using mws, we can setup a server mock for all APIs in a file, and we can use it easily.\n\n<div class=\"code-block__title\">responseData.js</div>\n\n```ts\nexport const greetingResponse = {\n    nickName: \"Hello World\",\n};\nexport const greetingErr = {\n    code: \"server.interupts\",\n    message: \"Sorry, the server interupts, please try later!\",\n};\n```\n\n<div class=\"code-block__title\">mockServerSetup.js</div>\n\n```ts\nimport { setupServer } from \"msw/node\";\nimport { rest } from \"msw\";\nimport { greetingErr, greetingResponse } from \"./responseData\";\n\nconst ApiPaths = {\n    GREETING: \"/greeting\",\n};\n\nconst HttpStatus = {\n    SUCCESS: 200,\n    BAD_REQUEST: 400,\n};\n\nconst HttpMethod = {\n    GET: \"get\",\n    POST: \"post\",\n    PUT: \"put\",\n    DELETE: \"delete\",\n};\n\nconst paths = {};\n\nconst server = setupServer();\n\nconst getKey = (path, method, status, code) => {\n    return `${path}.${method}.${status}.${code || \"\"}`;\n};\n\nconst use = (path, method, status, code) => {\n    switch (method) {\n        case HttpMethod.GET: {\n            server.use(rest.get(path, paths[getKey(path, method, status, code)]));\n            break;\n        }\n        default:\n            console.log(\"No default\");\n    }\n};\n\nconst addToPaths = (path, method, status, response, code) => {\n    const value = (req, res, ctx) => {\n        return res(ctx.status(status), ctx.json(response));\n    };\n    paths[getKey(path, method, status, code)] = value;\n    use(path, method, status);\n};\n\nconst initDefaultPaths = () => {\n    addToPaths(\n        ApiPaths.GREETING,\n        HttpMethod.GET,\n        HttpStatus.SUCCESS,\n        greetingResponse\n    );\n    addToPaths(\n        ApiPaths.GREETING,\n        HttpMethod.GET,\n        HttpStatus.BAD_REQUEST,\n        greetingErr\n    );\n};\n\nexport {\n    ApiPaths,\n    HttpStatus,\n    HttpMethod,\n    server,\n    initDefaultPaths,\n    addToPaths,\n    use,\n};\n```\n\nNow we can easy to use it in test like example below\n\n<div class=\"code-block__title\">MockApiComponent.js</div>\n\n```tsx\n/* eslint-disable jest/expect-expect */\n/* eslint-disable jest/no-disabled-tests */\nimport React from \"react\";\nimport { MockApiComponent } from \"./MockApiComponent\";\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport { greetingResponse } from \"../mockServerSetup/responseData\";\nimport {\n    server,\n    initDefaultPaths,\n    use,\n    ApiPaths,\n    HttpMethod,\n    HttpStatus,\n} from \"../mockServerSetup\";\n\ninitDefaultPaths();\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\n\ndescribe(\"MockAPIWithMsw\", () => {\n\n    test(\"render with api calling\", async () => {\n        use(ApiPaths.GREETING, HttpMethod.GET, HttpStatus.SUCCESS);\n        render(<MockApiComponent/>);\n\n        // Only one assertion within waitFor https://kentcdodds.com/blog/common-mistakes-with-react-testing-library\n        await waitFor(async () => {\n            expect(screen.getByTestId(\"nickName\")).toHaveTextContent(\n                greetingResponse.nickName\n            );\n        });\n    });\n});\n\n```\n\n### Mocking with jest mock\n\nIn this example, we mock the get method of axios to return a resolved value. This way just works when a component\ncalls an API by using axios.\n\n```tsx\nimport axios from 'axios';\n\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n\ndescribe('Render component correctly after data loaded', () => {\n    test('Home component render correctly', async () => {\n        mockedAxios.get.mockResolveValue({ nickName: 'hello World' });\n\n        render(<HomeComponent/>)\n\n        await userEvent.click(screen.getByText('Load Nickname'));\n\n        expect(mockedAxios.get).toHaveBeenCalled();\n        expect(screen.getByRole('span')).toHaveTextContent('Hello world');\n    })\n})\n```\n\nSo, how we can test the component that fetches data from multiple APIs, we can use `mockImplementation` of jest to do\nit.\n\n```tsx\nimport axios from 'axios';\n\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n\ndescribe('Render component correctly after data loaded', () => {\n    test('Home component render correctly', async () => {\n        const regexTemplate = {\n            'greeting': '/greeting/',\n            'greetingWithId': '/greeting\\/$/'\n        }\n        mockedAxios.get.mockImplementation((url) => {\n            switch (true) {\n                case regexTemplate['greeting'].test(url):\n                    return Promise.resolve({ data: { nickName: 'Hello world' } })\n                case regexTemplate['greetingWithId'].test(url):\n                    return Promise.resolve({ data: { nickName: 'Hello world with id' } })\n                default:\n                    return Promise.reject(new Error('not found'))\n            }\n        })\n\n        render(<HomeComponent/>)\n\n        await userEvent.click(screen.getByText('Load Nickname'));\n\n        expect(mockedAxios.get).toHaveBeenCalled();\n        expect(screen.getByRole('span')).toHaveTextContent('Hello world');\n    })\n})\n```\n\n## Test with React Router Dom\n\nNow we will combine both API and `react-router-dom`, the case is a component fetches user data, and then checking if\nthis\nuser is admin or not, if he is an admin, the user should be navigated to admin page.\n\n```tsx\nimport { MockRouteComponent } from \"./MockRouteComponent\";\nimport { render, screen, waitFor, fireEvent } from \"@testing-library/react\";\nimport axios from 'axios';\n\njest.mock('axios');\nconst mockedAxios = axios as jest.Mocked<typeof axios>;\n\nconst mockNavigate = jest.fn();\nconst mockShouldNavigateToHome = jest.fn();\n\njest.mock(\"react-router-dom\", () => {\n    const actualReactRouterDom = jest.requireActual(\"react-router-dom\");\n    return {\n        ...actualReactRouterDom,\n        useNavigate: () => mockNavigate,\n        useLocation: () => {\n            return {\n                state: {\n                    shouldNavigateToHome: mockShouldNavigateToHome(),\n                },\n            };\n        },\n    };\n});\n\ndescribe(\"MockRouteComponent\", () => {\n    test(\"render correctly\", async () => {\n        mockedAxios.get.mockResolveValue({ nickName: 'hello World', isAdmin: false });\n        render(<MockRouteComponent/>);\n        expect(mockNavigate).toBeCalledWith(\"/\");\n    });\n\n    test(\"render with api calling and then navigate\", async () => {\n        // IMPORTANT: Must reset the mock to avoid stored state\n        mockNavigate.mockReset();\n        mockedAxios.get.mockResolveValue({ nickName: 'hello World', isAdmin: true });\n        render(<MockRouteComponent/>);\n\n        // Only one assertion within waitFor https://kentcdodds.com/blog/common-mistakes-with-react-testing-library\n        await waitFor(async () => {\n            expect(screen.getByTestId(\"nickName\")).toHaveTextContent('hello World');\n        });\n        await waitFor(async () => {\n            expect(mockNavigate).toBeCalledWith(\"/admin\");\n        });\n    });\n});\n```\n\n## Test with i18n\n\nHow about if we combine with the i18n, i18n needs to have configuration about translation file, but actually\nwe can mock i18n and add just few keys related to the testing component.\n\n<div class=\"code-block__title\">i18n.test.js</div>\n\n```ts\njest.mock('i18n', () => {\n    return {\n        t: (key: string) => {\n            return 'mocked i18n';\n        },\n        i18n: {\n            language: 'en',\n        },\n    };\n});\n```\n\n## Test in complex components\n\nWhen we test, we will have complex component, but we just only care about the logic of this page and ignore other child\ncomponents, we can mock the others.\n\n<div class=\"code-block__title\">Homepage.tsx</div>\n\n```tsx\nconst HomePage = () => {\n    return (\n        <HomePageContainer>\n            <HeadSection/>\n            <BodySection/>\n            <FooterSection/>\n        </HomePageContainer>\n    );\n}\n```\n\n<div class=\"code-block__title\">Homepage.test.tsx</div>\n\n```tsx\njest.mock('./components', () => {\n    const HeadSection = (props) => <div data-testid=\"mock-HeadSection\" {...props} />;\n    const BodySection = (props) => <div data-testid=\"mock-BodySection\" {...props} />;\n    const FooterSection = (props) => <div data-testid=\"mock-FooterSection\" {...props} />;\n    return {\n        HeadSection, BodySection, FooterSection,\n    };\n});\n\ndescribe('HomePage', () => {\n    test('render correctly', () => {\n        const { getByTestId } = render(<HomePage/>);\n        expect(getByTestId('mock-HeadSection')).toBeTruthy();\n        expect(getByTestId('mock-BodySection')).toBeTruthy();\n        expect(getByTestId('mock-FooterSection')).toBeTruthy();\n    })\n})\n```\n\n## How to remove data-testid for production\n\nWe can use `babel-plugin-react-remove-properties` to remove `data-testid` attribute in production.\n\n```json\n{\n  \"plugins\": [\n    [\n      \"babel-plugin-react-remove-properties\",\n      {\n        \"properties\": [\n          \"data-testid\"\n        ]\n      }\n    ]\n  ]\n}\n```\n\n## Note\n\nWhen we unsure what we imagine what will render in test, we can log it to console log by\nthe command below\n\n```tsx\nconst component = render(<MyComponent/>);\nconsole.log(component.debug());\n```"},"__N_SSG":true}