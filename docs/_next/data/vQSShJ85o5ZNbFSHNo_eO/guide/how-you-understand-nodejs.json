{"pageProps":{"frontmatter":{"title":"How you understand nodejs","date":"March 14, 2022","excerpt":"Nodejs is non-blocking IO, but how you understand about it","tag":"nodejs","author":"Nghia Ngo","cover_image":"/images/posts/how-you-understand-nodejs/nodejs-cover.jpeg"},"slug":"how-you-understand-nodejs","content":"# Nodejs\n\nNode.js is an open-source and cross-platform JavaScript runtime environment.\n\nNode.js runs the [V8 JavaScript engine](https://v8.dev/), the core of Google Chrome.\n\nA Node.js app runs in a single thread, non-bloking I/O\n\n## What is non-blocking IO\n\n<details>\n<summary>Answer</summary>\n  The thread will not be blocked when calling APIs. That means it will immediately continue executing the code that comes after calling the API. Most non-blocking frameworks use infinite loop that constantly checks(polls) which often calls event-loop. You can look on this site to understand more about event-loop\n</details>\n\n[link](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)\n\n- How many types of blocking?\n\n  - I/O\n  - Interface\n  - operation\n\n  <details>\n  <summary>Answer</summary>\n    - CPU-bound blocking\n    <br/>\n    - IO-bound blocking\n  </details>\n\n- What is CPU-bound blocking?\n\n  - Relate to process of system\n\n  <details>\n  <summary>Answer</summary>\n    CPU-bound blocking is a thread which gets blocked because of some task requires CPU to perform, but not return instantly. For example, an algorithm executes with a large of data input.\n  </details>\n\n  - fs.readAsSync()\n  - crypto.generate()\n  - check timeout for connection\n\n- What is IO bound blocking?\n\n  - Calling third party\n  - Access files\n\n  <details>\n  <summary>Answer</summary>\n    A thread gets blocked by waiting for data from an IO. IO is the input and the output that refers to interaction with devices such as a hard drive, network or database.\n  </details>\n\n- What is difference between CPU bound blocking and IO bound blocking?\n\n  <details>\n  <summary>Answer</summary>\n    The difference shows on the state of threads.\n    <ol>\n      <li>With the CPU-bound blocking, it is still working until the result response.</li>\n      <li>With the IO-bound blocking, it sleeps when waiting the response, another process of IO will create another thread.</li>\n    </ol>\n  </details>\n\n## Why nodejs called single thread\n\n- In the end of this [topic](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/), we can see that Node.js has two types of threads: Event loop and `k` Workers. Therefore, why it called single thread when they have multiple workers to running the tasks including non-blocking I/O and CPU-intensive work.\n\n  ![event-loop](/blog/images/posts/how-you-understand-nodejs/event-loop.png)\n\n<details>\n<summary>Answer</summary>\n  Single thread here means the process will be based on the event loop to execute the I/O and CPU-intensive work. The workers as the name of it, it does the job that the event loop assigns and return the result to the event loop. Now we can see that we only have one event loop, despite more than one task finished by Worker, but it still waiting for the event loop.\n</details>\n\n## Nodejs processes and thread\n\n![multiple-process](/blog/images/posts/how-you-understand-nodejs/multiple-process.png)\n\n- Nodejs child process\n  - Share memory: event emiter\n  - kill proccess\n  - string -> data string -> child_process.emit(\"message\", data)\n  - processs.on(\"message\", ())\n  - Resolve the CPU bound in main thread\n- Nodejs cluster -> child process -> spawn based on amount of CPU cores \n  - Create multiple instances of nodejs app.\n- Nodejs worker thread\n  - Create in main thread, resolve the CPU bound in main thread.\n\nsetTimeout(): if the same number which one run first?\n\n- The runner come to the callback stack first will be called first. So the timeout don't really delay by the amount of time, the time in setTimeout means the lower bound of delay.\n\n\n\n## Exercise\n\nWrite an application with nodejs using the child proccess, cluster or worker thread  to show the different performace between using process or thread and without using them.\n\n- My suggestion is write an application has three APIs, one for CPU-intensive, another for I/O and the last one just an API to check health like /info.\n\n- 2 Nodejs app -> web server -> using APIs nodes -> 3 APIs\n  - health check\n  - execute I/O bound in this api. Example read a file\n  - execute CPU bound in this api. Example run sort large data.(Using cluster, child process or worker in the second app).\n"},"__N_SSG":true}