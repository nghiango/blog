{"pageProps":{"frontmatter":{"title":"Sub component for big complex component","date":"Feb 07, 2024","excerpt":"Guide to use React Hook Form with Yup","tag":"reactjs","author":"Nghia Ngo","cover_image":"/images/posts/how-you-understand-nodejs/nodejs-cover.jpeg"},"slug":"react-sub-component-for-big-complex-component","content":"\n# Introduction\nWhen we are working in a complex component, which are made up of many different pieces.\nWe can put all these components into a folder to show the relationship between them. But this way doesn't show the \nrelationship when we are using them. Therefore, to boost the relationship and speed up the development.\nWe can use sub-component to show the relationship between components.\n\n## What is sub-component\nSub-component is a child component that can be call by Parent component.\nFor example, we have a `Card` component, and we want to use `Header`, `Body`, `Footer` in `Card` component.\nWe can create `Header`, `Body`, `Footer` as sub-component of `Card` component.\nThen we export them inside `Card` component, and access them by `Card.Header`, `Card.Body`, `Card.Footer`.\n\n## Why we need sub-component\n### Namespacing\nAll sub-components are inherently namespaced under the parent component. Although we can use this component without\nthe parent component, the name of the sub-component will notify the user that it is a part of the parent component.\nTherefore, we don't take too much effort to see the relationship between them.\n### Single Import\nWith only parent component imported, we can call all sub-components. It's very convenient when we want to grow the\ncomponent in the future, and then we don't need to re-import the sub-components.\n### Discoverability\nWith namespacing, the developers don't need to remember the name of the sub-component. We just only need to know the parent\ncomponent, and then we can use dot notation to see all the sub-components.\n\n# How to create sub-component\nTo create sub-component, we have different ways to do it. We can use class component, function component.\n## Using class component\n\n```tsx\ninterface IHeaderProps {\n    children: React.ReactNode;\n}\nclass Header extends React.Component<IHeaderProps> {\n   public render() {\n        return (\n            <div className='card__header'>\n                {this.props.children}\n            </div>\n        );\n    }\n}\ninterface ICardProps {\n    children: React.ReactNode;\n}\nclass Card extends React.Component<IProps> {\n    public static Header = Header;\n    public render() {\n        return (\n            <div className='card'>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n```\nYou can refer to the example above, we can add `Body` and `Footer` in the same way as `Header`.\n\nAfter defined public static `Header`, `Body`, and `Footer`, we can use `Card.Header`, `Card.Body`, `Card.Footer` in the other place.\n\nHere is the example of usage:\n```tsx\nclass App extends React.Component {\n    render() {\n        return (\n            <Card>\n                <Card.Header>\n                    <h1>Header</h1>\n                </Card.Header>\n                <Card.Body>\n                    <p>Body</p>\n                </Card.Body>\n                <Card.Footer>\n                    <p>Footer</p>\n                </Card.Footer>\n            </Card>\n        );\n    }\n}\n```\n\n## Using function component\nFor the person who are familiar with function component, we can use function component to create sub-component.\n\n```tsx\ninterface IHeaderProps {\n    children: React.ReactNode;\n}\nconst Header: React.FC<IHeaderProps> = (props) => {\n    return (\n        <div className='card__header'>\n            {props.children}\n        </div>\n    );\n}\ninterface ICardProps {\n    children: React.ReactNode;\n}\nconst Card: React.FC<ICardProps> = (props) => {\n    return (\n        <div className='card'>\n            {props.children}\n        </div>\n    );\n}\nCard.Header = Header;\n```\n## Other stuffs related to sub-component\n### Component display name\nWhen we are using react dev tool, the sub-components named still show as `Header`, `Body`, `Footer`. It's not show as `Card.Header`, `Card.Body`, `Card.Footer`.\nTo enhance the connection between them, we can add `displayName` to the sub-component.\n\n```tsx\nclass Header extends React.Component<IHeaderProps> {\n    public static displayName = 'Card.Header';\n    public render() {\n        return (\n            <div className='card__header'>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n```\n### Constrain children only for sub-component\nTo constrain just only sub-components can be used in the parent component. We can use `React.Children` to check\nthe type of children.\n```tsx\nconst Card: React.FC = ({ children}) => {\n    const subComponentKeys = Object.keys(Card);\n    const childrenComponents = React.Children.map(children, (child) => {\n        if (subComponentKeys.includes(child.type.name)) {\n            return child;\n        }\n        return null;\n    });\n    return (\n        <div className='card'>\n            {childrenComponents}\n        </div>\n    );\n}\nconst Header: React.FC = ({ children}) => {\n    return (\n        <div className='card__header'>\n            {children}\n        </div>\n    );\n}\n// Card now will have a key `Header`\nCard.Header = Header;\n```\n\n### Automatically assign and add display name\n\nWe can use this function to assign children to the parent component, and add display name to children component.\n```tsx\nimport React from 'react';\n\n/**\n * Attaches subcomponents to a parent component for use in\n * composed components. Example:\n * \n * <Parent>\n *    <Parent.Title>abc</Parent.Title>\n *    <Parent.Body prop1=\"foobar\"/>\n * </Parent>\n * \n *\n * This function also sets displayname on the parent component\n * and all children component, and has the correct return type\n * for typescript.\n *\n * @param displayName topLevelComponent's displayName\n * @param topLevelComponent the parent element of the composed component\n * @param otherComponents an object of child components (keys are the names of the child components)\n * @returns the top level component with otherComponents as static properties\n */\nexport function attachSubComponents<\n  C extends React.ComponentType,\n  O extends Record<string, React.ComponentType>\n>(displayName: string, topLevelComponent: C, otherComponents: O): C & O {\n  topLevelComponent.displayName = displayName;\n  Object.values(otherComponents).forEach(\n    (component) =>\n      (component.displayName = `${displayName}.${component.displayName}`)\n  );\n\n  return Object.assign(topLevelComponent, otherComponents);\n}\n```\n\nHere is the example of usage:\n\n```tsx\nimport ReactMarkdown from 'react-markdown';\nimport children = ReactMarkdown.propTypes.children;\n\nconst InternalCard: React.FC = ({ children }) => {\n    return (\n        <div className='card'>\n            {children}\n        </div>\n    );\n}\nconst Header: React.FC = ({ children }) => {\n    return (\n        <div className='card__header'>\n            {children}\n        </div>\n    );\n}\nconst Body: React.FC = ({ children }) => {\n    return (\n        <div className='card__body'>\n            {children}\n        </div>\n    );\n}\nconst Footer: React.FC = ({ children }) => {\n    return (\n        <div className='card__footer'>\n            {children}\n        </div>\n    );\n}\nconst Card = attachSubComponents('Card', InternalCard, {\n    Header,\n    Body,\n    Footer\n});\n```\n## Problems may occur\n### Tree shaking\n[Tree shaking](https://webpack.js.org/guides/tree-shaking/) is a technique to remove the unused code from the bundle.\nWith this kind of implementation, the tree shaking may not work as expected. Because the sub-components are included in\nthe top-level component, and then it imports and exports all the sub-components when we use the top-level component.\n\nTherefore, when we have many unused sub-components, the bundle size doesn't decrease as expected.\nNevertheless, when we meet this problem, it means that we are overuse the sub-components, so we should split them into\nanother components.\n\n\n# Reference\n- [The best way to build a big react components](https://dev.to/devsatasurion/the-best-way-to-build-big-react-components-5295)\n- [Create react subcomponents](https://dev.to/hey_yogini/create-react-subcomponents-in-a-simple-way-5h1f)\n- [Using component dot notation with typescript](https://www.skovy.dev/blog/using-component-dot-notation-with-typescript-to-create-a-set-of-components?seed=i30o5s)"},"__N_SSG":true}