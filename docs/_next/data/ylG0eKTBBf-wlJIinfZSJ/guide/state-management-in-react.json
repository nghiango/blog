{"pageProps":{"frontmatter":{"title":"State management in React","date":"Feb 12, 2024","updated":"Mar 31, 2024","excerpt":"React now has many ways to manage state, but how to choose the best way for your project?","tag":"reactjs","author":"Nghia Ngo","cover_image":"/images/posts/how-you-understand-nodejs/nodejs-cover.jpeg"},"slug":"state-management-in-react","content":"# State management in React\nIn react we have many ways to manage state includes native with `useContext` and `useReducer`, and also many\nlibraries like `redux`, `mobx`, `recoil`, `jotai`, `zustand`, `react-query`, `swr`,...\n\nEach way has its own pros and cons, and it's hard to choose the best way for your project. In this article, I will introduce\nthe native way and some libraries, but also give you some comparison by my perspective. \n\n## React Context \nReact Context is a way to pass data through the component tree without having to pass props down manually at every level.\n\nContext will force re-render the component when the context value changes, so it's not suitable for the global state that changes frequently.\n\nCombine with `useReducer` to have a simple global state management.\n\nTherefore, I will structure the context like this:\n```\nsrc\n├── context\n│   ├── index.tsx\n│   ├── account\n│   │   ├── account.context.tsx\n│   │   ├── account.reducer.tsx\n\n```\n\nIn the `index.tsx` file, I use generic type to define the context providers that splits `value` and `dispatch` into two different contexts.\nYou may concern why we need to 2 contexts, it's because we want to avoid re-rendering the component that does not need to know about the dispatch.\n\n```tsx\nimport { createContext, Dispatch, ReactElement, useReducer } from \"react\";\nexport interface GenericAction<T> {\n    type: string;\n    payload: T;\n}\nexport interface GenericType {}\n\ninterface IProps<T, K> {\n    children: ReactElement | ReactElement[];\n    initialValues: T;\n    reducer: (state: T, action: K) => T;\n    [key: string]: any\n}\nexport const useProvider = <T extends GenericType, K extends GenericAction<T>>({ initialValues, reducer, children }: IProps<T, K>) => {\n    const [app, dispatch] = useReducer(reducer, initialValues);\n    const ProviderContext = createContext<T>(app);\n    const ProviderDispatchContext = createContext<Dispatch<K>>(dispatch);\n    return {\n        provider: (\n          <ProviderContext.Provider value={app}>\n              <ProviderDispatchContext.Provider value={dispatch}>\n                  {children}\n              </ProviderDispatchContext.Provider>\n          </ProviderContext.Provider>\n        ),\n        providerContext: ProviderContext,\n        providerDispatchContext: ProviderDispatchContext,\n    }\n}\n```\n\nNow, I will create a concrete context for the account.\n\nIn the `account.reducer.ts` file, I define two interfaces `IAccountState` and `IAccountAction`, a enum `AccountActionType`,\n and a `accountReducer` function.\n\n```tsx\nimport { GenericAction, GenericType } from '@/state-management/context/configuration';\n\nexport enum AccountActionType {\n  CHANGE_NAME = 'changeName',\n  CHANGE_PASSWORD = 'changePassword'\n}\n\nexport interface IAccountState extends GenericType {\n  username: string;\n  password: string;\n}\n\nexport interface IAccountAction extends GenericAction<IAccountState> {\n  type: AccountActionType;\n  payload: IAccountState;\n}\n\nexport const accountReducer = (state: IAccountState, action: IAccountAction) => {\n  switch (action.type) {\n    case AccountActionType.CHANGE_NAME: {\n      return { ...state, username: action.payload.username }\n    }\n    case AccountActionType.CHANGE_PASSWORD: {\n      return { ...state, password: action.payload.password }\n    }\n  }\n}\n```\n\nIn the `account.context.tsx` file, I define the `AccountProvider` that uses the `useProvider` function to create the context provider,\nand export two hooks for account context, which are `useAccount` and `useAccountDispatch`.\n\n```tsx\nimport { useProvider } from '@/state-management/context/configuration';\nimport { Context, Dispatch, ReactElement, useContext } from 'react';\nimport {\n  accountReducer,\n  IAccountAction,\n  IAccountState\n} from '@/state-management/context/configuration/account/account.reducer';\n\n\nlet accountContext: Context<IAccountState>, accountDispatchContext: Context<Dispatch<IAccountAction>>;\nexport const useAccountContext = () => {\n  return {\n    accountState: useContext(accountContext),\n    accountDispatch: useContext(accountDispatchContext)\n  }\n}\n\nconst defaultValue: IAccountState = {\n  username: '',\n  password: ''\n}\n\ninterface IProps {\n  children: ReactElement | ReactElement[];\n}\nexport const AccountProvider = ({ children }: IProps) => {\n  const { provider, providerDispatchContext, providerContext } = useProvider<IAccountState, IAccountAction>(\n    { initialValues: defaultValue, reducer: accountReducer, children });\n  accountContext = providerContext;\n  accountDispatchContext = providerDispatchContext;\n  return provider;\n}\n```\n\n## React Redux\n\n## Mobx\n\n## React Query and SWR\n"},"__N_SSG":true}