<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/1b83b19899daad40.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/1b83b19899daad40.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-701f6a78412d5185.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-de0699283ff4f1d0.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-19399bcdf56baa52.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-8632c6a178bb83ff.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/6c86d9ce-5c3713bcd78fdc7a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/162-ae367f7794a4e1a0.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/guide/%5Bslug%5D-e55bca3e70a27023.js" defer="" crossorigin=""></script><script src="/_next/static/ylG0eKTBBf-wlJIinfZSJ/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/ylG0eKTBBf-wlJIinfZSJ/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="page__container"><div class="fixed bg-white w-full z-10" data-headlessui-state=""><div class="mx-auto px-4 sm:px-6 position-fixed"><div class="flex items-center border-b-2 border-gray-100 py-6 md:justify-start md:space-x-10"><div class="flex justify-start"><div class="relative" data-headlessui-state=""><a href="/"><span class="text-gray-500 cursor-pointer group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true" class="h-9 w-9 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg> <span class="text-xl pt-1">HOME</span></span></a></div><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div></div><nav class="hidden md:flex space-x-10"><div class="relative" data-headlessui-state=""><button class="text-gray-500 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" type="button" aria-expanded="false" data-headlessui-state=""><span>Devs Document</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" class="text-gray-400 ml-2 h-5 w-5 group-hover:text-gray-500"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div></nav><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div><nav class="hidden md:flex space-x-10"><div class="relative" data-headlessui-state=""><button class="text-gray-500 group bg-white rounded-md inline-flex items-center text-base font-medium hover:text-gray-900 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" type="button" aria-expanded="false" data-headlessui-state=""><a href="/info/about-me"><span>About me</span></a></button></div></nav><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div></div></div></div><div style="position:fixed;top:1px;left:1px;width:1px;height:0;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0;display:none"></div><main class="container w-100 lg:w-8/12 mx-auto flex flex-col pb-16 pt-40"><div class="card card-page"><div class="post__header"><h1 class="post__title post--padding">How you understand nodejs</h1><div class="post__author post--padding"><p>By <span class="font-bold">Nghia Ngo</span></p><span class="text-sm">March 14, 2022</span></div><img class="post__image-cover" src="/images/posts/how-you-understand-nodejs/nodejs-cover.jpeg" alt="image-cover"/></div><div class="post__body post--padding"><h1>Nodejs</h1>
<p class=" code-block__paragraph">Node.js is an open-source and cross-platform JavaScript runtime environment.</p>
<p class=" code-block__paragraph">Node.js runs the <a href="https://v8.dev/" class=" code-block__link">V8 JavaScript engine</a>, the core of Google Chrome.</p>
<p class=" code-block__paragraph">A Node.js app runs in a single thread, non-bloking I/O</p>
<h2>What is non-blocking IO</h2>
<details>
<summary>Answer</summary>
  The thread will not be blocked when calling APIs. That means it will immediately continue executing the code that comes after calling the API. Most non-blocking frameworks use infinite loop that constantly checks(polls) which often calls event-loop. You can look on this site to understand more about event-loop
</details>
<p class=" code-block__paragraph"><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" class=" code-block__link">link</a></p>
<ul>
<li>
<p class=" code-block__paragraph">How many types of blocking?</p>
<ul>
<li>I/O</li>
<li>Interface</li>
<li>operation</li>
</ul>
<details>
<summary>Answer</summary>
  - CPU-bound blocking
  <br/>
  - IO-bound blocking
</details>
</li>
<li>
<p class=" code-block__paragraph">What is CPU-bound blocking?</p>
<ul>
<li>Relate to process of system</li>
</ul>
<details>
<summary>Answer</summary>
  CPU-bound blocking is a thread which gets blocked because of some task requires CPU to perform, but not return instantly. For example, an algorithm executes with a large of data input.
</details>
<ul>
<li>fs.readAsSync()</li>
<li>crypto.generate()</li>
<li>check timeout for connection</li>
</ul>
</li>
<li>
<p class=" code-block__paragraph">What is IO bound blocking?</p>
<ul>
<li>Calling third party</li>
<li>Access files</li>
</ul>
<details>
<summary>Answer</summary>
  A thread gets blocked by waiting for data from an IO. IO is the input and the output that refers to interaction with devices such as a hard drive, network or database.
</details>
</li>
<li>
<p class=" code-block__paragraph">What is difference between CPU bound blocking and IO bound blocking?</p>
<details>
<summary>Answer</summary>
  The difference shows on the state of threads.
  <ol>
    <li>With the CPU-bound blocking, it is still working until the result response.</li>
    <li>With the IO-bound blocking, it sleeps when waiting the response, another process of IO will create another thread.</li>
  </ol>
</details>
</li>
</ul>
<h2>Why nodejs called single thread</h2>
<ul>
<li>
<p class=" code-block__paragraph">In the end of this <a href="https://nodejs.org/en/docs/guides/dont-block-the-event-loop/" class=" code-block__link">topic</a>, we can see that Node.js has two types of threads: Event loop and <code value="k" class="code-block__code">k</code> Workers. Therefore, why it called single thread when they have multiple workers to running the tasks including non-blocking I/O and CPU-intensive work.</p>
<p class=" code-block__paragraph"><img src="/images/posts/how-you-understand-nodejs/event-loop.png" alt="event-loop"/></p>
</li>
</ul>
<details>
<summary>Answer</summary>
  Single thread here means the process will be based on the event loop to execute the I/O and CPU-intensive work. The workers as the name of it, it does the job that the event loop assigns and return the result to the event loop. Now we can see that we only have one event loop, despite more than one task finished by Worker, but it still waiting for the event loop.
</details>
<h2>Nodejs processes and thread</h2>
<p class=" code-block__paragraph"><img src="/images/posts/how-you-understand-nodejs/multiple-process.png" alt="multiple-process"/></p>
<ul>
<li>Nodejs child process
<ul>
<li>Share memory: event emiter</li>
<li>kill proccess</li>
<li>string -&gt; data string -&gt; child_process.emit(&quot;message&quot;, data)</li>
<li>processs.on(&quot;message&quot;, ())</li>
<li>Resolve the CPU bound in main thread</li>
</ul>
</li>
<li>Nodejs cluster -&gt; child process -&gt; spawn based on amount of CPU cores
<ul>
<li>Create multiple instances of nodejs app.</li>
</ul>
</li>
<li>Nodejs worker thread
<ul>
<li>Create in main thread, resolve the CPU bound in main thread.</li>
</ul>
</li>
</ul>
<p class=" code-block__paragraph">setTimeout(): if the same number which one run first?</p>
<ul>
<li>The runner come to the callback stack first will be called first. So the timeout don&#x27;t really delay by the amount of time, the time in setTimeout means the lower bound of delay.</li>
</ul>
<h2>Exercise</h2>
<p class=" code-block__paragraph">Write an application with nodejs using the child proccess, cluster or worker thread  to show the different performace between using process or thread and without using them.</p>
<ul>
<li>
<p class=" code-block__paragraph">My suggestion is write an application has three APIs, one for CPU-intensive, another for I/O and the last one just an API to check health like /info.</p>
</li>
<li>
<p class=" code-block__paragraph">2 Nodejs app -&gt; web server -&gt; using APIs nodes -&gt; 3 APIs</p>
<ul>
<li>health check</li>
<li>execute I/O bound in this api. Example read a file</li>
<li>execute CPU bound in this api. Example run sort large data.(Using cluster, child process or worker in the second app).</li>
</ul>
</li>
</ul></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"frontmatter":{"title":"How you understand nodejs","date":"March 14, 2022","excerpt":"Nodejs is non-blocking IO, but how you understand about it","tag":"nodejs","author":"Nghia Ngo","cover_image":"/images/posts/how-you-understand-nodejs/nodejs-cover.jpeg"},"slug":"how-you-understand-nodejs","content":"# Nodejs\n\nNode.js is an open-source and cross-platform JavaScript runtime environment.\n\nNode.js runs the [V8 JavaScript engine](https://v8.dev/), the core of Google Chrome.\n\nA Node.js app runs in a single thread, non-bloking I/O\n\n## What is non-blocking IO\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n  The thread will not be blocked when calling APIs. That means it will immediately continue executing the code that comes after calling the API. Most non-blocking frameworks use infinite loop that constantly checks(polls) which often calls event-loop. You can look on this site to understand more about event-loop\n\u003c/details\u003e\n\n[link](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)\n\n- How many types of blocking?\n\n  - I/O\n  - Interface\n  - operation\n\n  \u003cdetails\u003e\n  \u003csummary\u003eAnswer\u003c/summary\u003e\n    - CPU-bound blocking\n    \u003cbr/\u003e\n    - IO-bound blocking\n  \u003c/details\u003e\n\n- What is CPU-bound blocking?\n\n  - Relate to process of system\n\n  \u003cdetails\u003e\n  \u003csummary\u003eAnswer\u003c/summary\u003e\n    CPU-bound blocking is a thread which gets blocked because of some task requires CPU to perform, but not return instantly. For example, an algorithm executes with a large of data input.\n  \u003c/details\u003e\n\n  - fs.readAsSync()\n  - crypto.generate()\n  - check timeout for connection\n\n- What is IO bound blocking?\n\n  - Calling third party\n  - Access files\n\n  \u003cdetails\u003e\n  \u003csummary\u003eAnswer\u003c/summary\u003e\n    A thread gets blocked by waiting for data from an IO. IO is the input and the output that refers to interaction with devices such as a hard drive, network or database.\n  \u003c/details\u003e\n\n- What is difference between CPU bound blocking and IO bound blocking?\n\n  \u003cdetails\u003e\n  \u003csummary\u003eAnswer\u003c/summary\u003e\n    The difference shows on the state of threads.\n    \u003col\u003e\n      \u003cli\u003eWith the CPU-bound blocking, it is still working until the result response.\u003c/li\u003e\n      \u003cli\u003eWith the IO-bound blocking, it sleeps when waiting the response, another process of IO will create another thread.\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/details\u003e\n\n## Why nodejs called single thread\n\n- In the end of this [topic](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/), we can see that Node.js has two types of threads: Event loop and `k` Workers. Therefore, why it called single thread when they have multiple workers to running the tasks including non-blocking I/O and CPU-intensive work.\n\n  ![event-loop](/images/posts/how-you-understand-nodejs/event-loop.png)\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n  Single thread here means the process will be based on the event loop to execute the I/O and CPU-intensive work. The workers as the name of it, it does the job that the event loop assigns and return the result to the event loop. Now we can see that we only have one event loop, despite more than one task finished by Worker, but it still waiting for the event loop.\n\u003c/details\u003e\n\n## Nodejs processes and thread\n\n![multiple-process](/images/posts/how-you-understand-nodejs/multiple-process.png)\n\n- Nodejs child process\n  - Share memory: event emiter\n  - kill proccess\n  - string -\u003e data string -\u003e child_process.emit(\"message\", data)\n  - processs.on(\"message\", ())\n  - Resolve the CPU bound in main thread\n- Nodejs cluster -\u003e child process -\u003e spawn based on amount of CPU cores \n  - Create multiple instances of nodejs app.\n- Nodejs worker thread\n  - Create in main thread, resolve the CPU bound in main thread.\n\nsetTimeout(): if the same number which one run first?\n\n- The runner come to the callback stack first will be called first. So the timeout don't really delay by the amount of time, the time in setTimeout means the lower bound of delay.\n\n\n\n## Exercise\n\nWrite an application with nodejs using the child proccess, cluster or worker thread  to show the different performace between using process or thread and without using them.\n\n- My suggestion is write an application has three APIs, one for CPU-intensive, another for I/O and the last one just an API to check health like /info.\n\n- 2 Nodejs app -\u003e web server -\u003e using APIs nodes -\u003e 3 APIs\n  - health check\n  - execute I/O bound in this api. Example read a file\n  - execute CPU bound in this api. Example run sort large data.(Using cluster, child process or worker in the second app).\n"},"__N_SSG":true},"page":"/guide/[slug]","query":{"slug":"how-you-understand-nodejs"},"buildId":"ylG0eKTBBf-wlJIinfZSJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>